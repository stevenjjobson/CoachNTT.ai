📋 Project Context Rules
yaml# Project Understanding
project_name: "Coach.ai - Cognitive Development Partner"
project_type: "AI-powered development assistant with temporal memory"
primary_language: "Python 3.11+"
secondary_languages: ["TypeScript", "SQL", "Bash"]

# Core Architecture Awareness
architecture:
  - "PostgreSQL with pgvector for memory storage"
  - "FastAPI for REST API"
  - "Obsidian vault for knowledge management"
  - "Docker-based deployment"
  - "Temporal memory with time-weighted degradation"

# Project Structure
key_directories:
  src: "Source code - memory, intent, API"
  scripts: "Automation scripts - development, testing, documentation"
  vault: "Obsidian knowledge base"
  tests: "Test suites - unit, integration, e2e"
  docker: "Container configurations"
🛠️ Development Workflow Rules
yaml# Checkpoint-Based Development
workflow_rules:
  - "ALWAYS create a checkpoint before major changes"
  - "NEVER modify code mid-implementation without checkpoint"
  - "Document changes in vault IMMEDIATELY after implementation"
  - "Run tests before creating any checkpoint"
  - "Update scripts/documentation when changing functionality"

# Context Window Management
context_management:
  - "Limit file references to maximum 5 per session"
  - "Complete atomic tasks before moving to next"
  - "Create vault note when context exceeds 80%"
  - "Segment complex implementations into sub-tasks"
  - "Always include relevant PRD section reference"

# Git Commit Standards
git_conventions:
  - "Use conventional commits: feat|fix|docs|style|refactor|test|chore"
  - "Reference issue numbers in commits"
  - "Create feature branches from develop"
  - "Squash commits before merging"
  - "Update changelog after features"
💻 Code Generation Rules
yaml# Python Code Standards
python_rules:
  - "Use type hints for ALL function parameters and returns"
  - "Follow PEP 8 with line length 88 (Black formatter)"
  - "Use dataclasses for data models"
  - "Implement docstrings with Google style"
  - "Handle exceptions explicitly"
  - "Use async/await for I/O operations"
  - "Import order: stdlib, third-party, local"

# SQL Standards
sql_rules:
  - "Use UPPERCASE for SQL keywords"
  - "Include explicit column lists in INSERT"
  - "Add comments for complex queries"
  - "Use parameterized queries (no string concatenation)"
  - "Include migration rollback scripts"
  - "Test on partitioned tables"

# Testing Requirements
testing_rules:
  - "Write tests BEFORE implementation (TDD preferred)"
  - "Minimum 90% code coverage"
  - "Use pytest fixtures for setup"
  - "Mock external dependencies"
  - "Include edge cases and error scenarios"
  - "Performance tests for memory operations"
📊 Database Interaction Rules
yaml# PostgreSQL Specific
database_rules:
  - "ALWAYS use connection pooling"
  - "Include explicit transaction boundaries"
  - "Use JSONB for flexible metadata"
  - "Implement proper index usage"
  - "Handle partition management"
  - "Use prepared statements"

# Memory Storage Patterns
memory_patterns:
  - "Store prompt-code pairs atomically"
  - "Include embedding generation"
  - "Update degradation weights asynchronously"
  - "Implement batch operations for performance"
  - "Validate JSONB structure before insert"
📝 Documentation Rules
yaml# Code Documentation
documentation_standards:
  - "Every module needs a docstring"
  - "Complex functions need examples"
  - "Include type information in docstrings"
  - "Document exceptions raised"
  - "Add 'Since' version tags for new features"

# Vault Integration
vault_rules:
  - "Create vault note for each major feature"
  - "Use provided templates for consistency"
  - "Include mermaid diagrams for flows"
  - "Add backlinks to related concepts"
  - "Tag with appropriate categories"
  - "Update index files after changes"

# README Updates
readme_maintenance:
  - "Update feature list after implementation"
  - "Include setup instructions changes"
  - "Add new script documentation"
  - "Update architecture diagrams"
  - "Maintain troubleshooting section"
🔧 Script Development Rules
yaml# Script Standards
script_rules:
  - "Include help text and usage examples"
  - "Add error handling and validation"
  - "Use consistent naming: kebab-case.sh or snake_case.py"
  - "Log all operations to script execution table"
  - "Support dry-run mode where applicable"
  - "Include rollback capabilities"

# Script Categories
script_organization:
  development: "Checkpoints, monitoring, analysis"
  testing: "Test runners, benchmarks, coverage"
  documentation: "Generators, sync, updates"
  database: "Migrations, backups, optimization"
  utilities: "Setup, cleanup, monitoring"
🚨 Quality Assurance Rules
yaml# Code Review Checklist
review_requirements:
  - "Passes all existing tests"
  - "Includes new tests for new code"
  - "Updates documentation"
  - "No hardcoded values"
  - "Handles errors gracefully"
  - "Follows naming conventions"
  - "Includes performance considerations"

# Security Considerations
security_rules:
  - "No credentials in code"
  - "Use environment variables"
  - "Validate all inputs"
  - "Sanitize for SQL injection"
  - "Implement rate limiting"
  - "Log security events"
🎯 AI-Specific Behavior Rules
yaml# Memory System Understanding
memory_behavior:
  - "Respect temporal degradation in queries"
  - "Never override explicit user instructions"
  - "Provide confidence scores for suggestions"
  - "Maintain context across related queries"
  - "Update weights based on usage"

# Intent Engine Guidelines
intent_processing:
  - "Identify peripheral connections"
  - "Explain reasoning for suggestions"
  - "Respect non-directive principle"
  - "Learn from acceptance patterns"
  - "Provide multiple alternatives"

# Embedding Generation
embedding_rules:
  - "Generate for all code blocks"
  - "Update on significant changes"
  - "Cache for performance"
  - "Handle multiple languages"
  - "Normalize before storage"
📋 Implementation Patterns
yaml# Common Patterns
design_patterns:
  - "Repository pattern for data access"
  - "Service layer for business logic"
  - "Factory pattern for object creation"
  - "Strategy pattern for algorithms"
  - "Observer pattern for events"

# Error Handling
error_patterns:
  - "Use custom exceptions"
  - "Include error context"
  - "Log before re-raising"
  - "Provide user-friendly messages"
  - "Include recovery suggestions"

# Performance Patterns
performance_rules:
  - "Batch database operations"
  - "Use connection pooling"
  - "Implement caching strategically"
  - "Profile before optimizing"
  - "Monitor resource usage"
🔄 Continuous Integration Rules
yaml# CI/CD Pipeline
pipeline_rules:
  - "Run tests on every push"
  - "Check code coverage"
  - "Validate documentation"
  - "Run security scans"
  - "Build Docker images"
  - "Deploy to staging first"

# Quality Gates
quality_thresholds:
  test_coverage: 90
  documentation_coverage: 85
  complexity_threshold: 10
  security_score: "A"
  performance_baseline: "100ms p95"
💡 Special Considerations
yaml# Project-Specific Constraints
constraints:
  - "Maintain backward compatibility"
  - "Support offline vault access"
  - "Handle large memory datasets"
  - "Optimize for single developer"
  - "Enable collaborative features"

# Future-Proofing
extensibility:
  - "Design for plugin architecture"
  - "Plan for multi-language support"
  - "Consider distributed deployment"
  - "Allow custom memory algorithms"
  - "Support external integrations"
📝 Example Rule Application
python# Example: Creating a new memory service method
class MemoryService:
    async def search_memories(
        self,
        query: str,
        *,
        limit: int = 10,
        min_weight: float = 0.1,
        include_code: bool = True
    ) -> List[MemoryEntry]:
        """
        Search memories using hybrid semantic and keyword search.
        
        Args:
            query: Search query text
            limit: Maximum results to return
            min_weight: Minimum degradation weight threshold
            include_code: Whether to include code in results
            
        Returns:
            List of matching memory entries sorted by relevance
            
        Raises:
            ValidationError: If query is empty or limit < 1
            DatabaseError: If search operation fails
            
        Example:
            >>> memories = await service.search_memories(
            ...     "docker configuration",
            ...     limit=5
            ... )
            
        Since: v1.0.0
        """
        # Implementation follows all rules:
        # - Type hints ✓
        # - Docstring ✓
        # - Error handling ✓
        # - Async operation ✓
        # - Parameter validation ✓
🚀 Quick Reference Commands
bash# Development workflow
make checkpoint        # Create development checkpoint
make test             # Run test suite
make docs-update      # Update documentation
make vault-sync       # Sync to Obsidian

# Code quality
make lint             # Run code linters
make format           # Auto-format code
make security-check   # Security scan
make complexity       # Check code complexity

# Database operations
make db-migrate       # Run migrations
make db-backup        # Backup database
make db-optimize      # Optimize indexes